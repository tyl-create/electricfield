<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>電場模擬 (效能保護版)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <style>
    body { 
      margin: 0; overflow: hidden; background: #000; 
      font-family: 'Segoe UI', sans-serif; 
      touch-action: none; /* 禁止瀏覽器預設觸控行為 */
      user-select: none; -webkit-user-select: none;
    }

    /* 頂部按鈕 */
    #top-bar {
      position: fixed; top: 0; left: 0; width: 100%;
      background: rgba(20,20,20,0.85); padding: 12px 0;
      display: flex; justify-content: center; gap: 15px; z-index: 20;
      backdrop-filter: blur(5px);
    }
    button {
      padding: 8px 16px; border: none; border-radius: 20px;
      font-weight: bold; color: white; cursor: pointer;
      font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .btn-add { background: #555; border: 1px solid #777; }
    .btn-reset { background: #d32f2f; }
    button:active { transform: scale(0.95); }

    /* 底部 HUD */
    #hud {
      position: fixed; bottom: 0; left: 0; width: 100%;
      background: rgba(0,0,0,0.85); color: white;
      padding: 12px; box-sizing: border-box;
      display: flex; justify-content: space-around;
      font-family: monospace; z-index: 20; border-top: 1px solid #333;
    }
    .hud-val { font-size: 1.3rem; font-weight: bold; margin-left: 5px; }
    
    /* 提示與說明 */
    #hint {
      position: absolute; top: 60px; width: 100%; text-align: center;
      color: rgba(255,255,255,0.5); font-size: 13px; pointer-events: none;
    }
  </style>
</head>
<body>

  <div id="top-bar">
    <button class="btn-add" onclick="addCharge(1)">+1C</button>
    <button class="btn-add" onclick="addCharge(-1)">-1C</button>
    <button class="btn-reset" onclick="resetSim()">重置</button>
  </div>

  <div id="hint">點擊圓球修改數值 (上限 ±5)<br>拖動黃色準心觀測場強</div>

  <div id="hud">
    <div>E:<span id="e-val" class="hud-val" style="color:#ffe600">0.00</span></div>
    <div>V:<span id="v-val" class="hud-val">0.00</span></div>
  </div>

  <script>
    // --- 效能與限制參數 ---
    const MAX_CHARGES_COUNT = 6;  // 最多允許 6 個電荷
    const MAX_CHARGE_VAL = 5;     // 單一電荷最大數值 (±5)
    const LINES_PER_COULOMB = 10; // 線條密度 (每1單位電荷產生幾條線)
    const MAX_STEPS = 500;        // 線條繪製最大步數 (避免跑太遠)
    const STEP_SIZE = 6;          // 步長
    const K_CONST = 5000;         // 模擬常數

    let charges = [];
    let observer;
    let draggedObj = null;
    let clickStartTime = 0;
    
    // DOM 元素
    let eDisplay, vDisplay;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      eDisplay = select('#e-val');
      vDisplay = select('#v-val');
      
      // 預設場景
      charges.push(new Charge(width * 0.35, height / 2, 1));
      charges.push(new Charge(width * 0.65, height / 2, -1));
      observer = new Observer(width/2, height/2 - 100);
    }

    function draw() {
      background(15);

      // 1. 繪製連續電力線
      drawFieldLines();

      // 2. 繪製電荷
      for (let c of charges) {
        c.display();
      }

      // 3. 繪製並更新觀測點
      observer.update();
      observer.display();
    }

    // --- 核心演算法：連續電力線 ---
    function drawFieldLines() {
      noFill();
      strokeWeight(1.5);
      
      // 找出所有正電荷作為發射源
      let positiveCharges = charges.filter(c => c.q > 0);

      for (let pCharge of positiveCharges) {
        // 限制最大線條數，防止單一電荷過大時雖然數值被擋，但顯示上仍跑太多
        let displayQ = constrain(Math.abs(pCharge.q), 0, MAX_CHARGE_VAL);
        let numLines = Math.floor(displayQ * LINES_PER_COULOMB);
        
        for (let i = 0; i < numLines; i++) {
          let angle = (TWO_PI / numLines) * i;
          let startR = pCharge.r + 2; 
          let currX = pCharge.x + startR * cos(angle);
          let currY = pCharge.y + startR * sin(angle);

          stroke(255, 255, 255, 90); // 線條顏色與透明度
          beginShape();
          vertex(currX, currY);

          for (let step = 0; step < MAX_STEPS; step++) {
            let res = calculateField(currX, currY);
            
            // 終止條件：場強過弱、出界
            if (res.E_mag < 0.05 || 
                currX < -50 || currX > width+50 || 
                currY < -50 || currY > height+50) {
              break;
            }

            // 推進
            let dx = (res.Ex / res.E_mag) * STEP_SIZE;
            let dy = (res.Ey / res.E_mag) * STEP_SIZE;
            currX += dx;
            currY += dy;
            vertex(currX, currY);

            // 終止條件：撞入負電荷
            let hit = false;
            for (let nCharge of charges) {
              if (nCharge.q < 0) {
                if (dist(currX, currY, nCharge.x, nCharge.y) < nCharge.r) {
                  hit = true; break;
                }
              }
            }
            if (hit) break;
          }
          endShape();
        }
      }
    }

    // --- 物理計算 ---
    function calculateField(x, y) {
      let Ex = 0, Ey = 0, V = 0;
      for (let c of charges) {
        let dx = x - c.x;
        let dy = y - c.y;
        let dSq = dx*dx + dy*dy;
        let d = sqrt(dSq);
        if (d < 1) d = 1;

        let E = (K_CONST * c.q) / dSq;
        Ex += E * (dx / d);
        Ey += E * (dy / d);
        V += (K_CONST * c.q) / d / 10;
      }
      return { Ex, Ey, E_mag: sqrt(Ex*Ex + Ey*Ey), V };
    }

    // --- 物件類別 ---
    class Charge {
      constructor(x, y, q) {
        this.x = x; this.y = y; this.q = q;
        this.updateSize();
      }
      updateSize() {
        // 限制顯示大小
        let sizeMag = constrain(Math.abs(this.q), 0, MAX_CHARGE_VAL);
        this.r = 25 + sizeMag * 5; 
      }
      display() {
        noStroke();
        if (this.q > 0) fill(255, 60, 60);
        else if (this.q < 0) fill(60, 100, 255);
        else fill(150);
        ellipse(this.x, this.y, this.r * 2);
        
        fill(255); textAlign(CENTER, CENTER); textSize(15);
        text(this.q + "C", this.x, this.y);
      }
    }

    class Observer {
      constructor(x, y) { this.x = x; this.y = y; }
      update() {
        let res = calculateField(this.x, this.y);
        this.Ex = res.Ex; this.Ey = res.Ey;
        eDisplay.html(res.E_mag.toFixed(2));
        vDisplay.html(res.V.toFixed(2));
      }
      display() {
        stroke('#ffe600'); strokeWeight(2); noFill();
        ellipse(this.x, this.y, 22);
        line(this.x-15, this.y, this.x+15, this.y);
        line(this.x, this.y-15, this.x, this.y+15);

        let len = mag(this.Ex, this.Ey);
        if (len > 0.1) {
          push(); translate(this.x, this.y); rotate(atan2(this.Ey, this.Ex));
          let arrowLen = constrain(len*2, 0, 70);
          stroke('rgba(255,230,0,0.8)');
          line(0,0, arrowLen, 0);
          noFill(); line(arrowLen, 0, arrowLen-6, -6); line(arrowLen, 0, arrowLen-6, 6);
          pop();
        }
      }
    }

    // --- 互動與限制邏輯 ---

    function touchStarted() { handleStart(); return false; }
    function mousePressed() { handleStart(); }

    function handleStart() {
      clickStartTime = millis();
      let mX = mouseX, mY = mouseY;
      if (dist(mX, mY, observer.x, observer.y) < 35) { draggedObj = observer; return; }
      for (let c of charges) {
        if (dist(mX, mY, c.x, c.y) < c.r + 10) { draggedObj = c; return; }
      }
    }

    function touchMoved() { handleMove(); return false; }
    function mouseDragged() { handleMove(); }

    function handleMove() {
      if (draggedObj) {
        draggedObj.x = constrain(mouseX, 30, width-30);
        draggedObj.y = constrain(mouseY, 60, height-80);
      }
    }

    function touchEnded() { handleEnd(); }
    function mouseReleased() { handleEnd(); }

    function handleEnd() {
      // 判定為點擊 (短按)
      if (millis() - clickStartTime < 250 && draggedObj instanceof Charge) {
        editCharge(draggedObj);
      }
      draggedObj = null;
    }

    // [重點] 驗證輸入數值
    function editCharge(c) {
      let hint = `請輸入電荷量\n範圍限制：-${MAX_CHARGE_VAL} 到 ${MAX_CHARGE_VAL}`;
      let input = prompt(hint, c.q);
      
      if (input !== null) {
        let val = parseFloat(input);
        
        // 檢查 1: 是否為數字
        if (isNaN(val)) {
          alert("格式錯誤，請輸入數字！");
          return;
        }

        // 檢查 2: 範圍限制
        if (Math.abs(val) > MAX_CHARGE_VAL) {
          alert(`數值太大囉！為了手機跑得順，最大只能設定為 ±${MAX_CHARGE_VAL}。`);
          return;
        }

        // 通過驗證
        c.q = val;
        c.updateSize();
      }
    }

    // [重點] 限制新增數量
    function addCharge(q) {
      if (charges.length >= MAX_CHARGES_COUNT) {
        alert(`畫面太擠了！為了效能，最多只能放置 ${MAX_CHARGES_COUNT} 個電荷。`);
        return;
      }
      // 在畫面中間隨機位置生成，避免重疊
      charges.push(new Charge(width/2 + random(-40,40), height/2 + random(-40,40), q));
    }

    function resetSim() { charges = []; setup(); }
    function windowResized() { resizeCanvas(windowWidth, windowHeight); }
  </script>
</body>
</html>
